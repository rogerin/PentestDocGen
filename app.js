const fs = require('fs');
const PizZip = require('pizzip');
const Docxtemplater = require('docxtemplater');


function countIssues(issueType, issuesArray) {
    // Filtra o array para obter apenas os objetos onde a propriedade 'item' é igual a 'issueType'
    const filteredIssues = issuesArray.filter(issue => issue.severity === issueType);
    // Retorna a quantidade de elementos no array filtrado
    return filteredIssues.length;
}
const content = fs.readFileSync('templates/soft-from-pentest.docx', 'binary');

const zip = new PizZip(content);
const doc = new Docxtemplater(zip, {
    paragraphLoop: true,
    linebreaks: true,
});

// Carrega os dados do arquivo JSON
const data = JSON.parse(fs.readFileSync('reports/jobs/kshvaelz2iaadzc91jxtus2r10t8.tempest.net.br:9041/data.json', 'utf8'));


const criticalQnt = countIssues('Critical', data.issues);
const highQnt = countIssues('High', data.issues);
const mediumQnt = countIssues('Medium', data.issues);
const lowQnt = countIssues('Low', data.issues);
const informationalQnt = countIssues('Informational', data.issues);

data.criticalQnt = criticalQnt;
data.highQnt = highQnt;
data.mediumQnt = mediumQnt;
data.lowQnt = lowQnt;
data.informationalQnt = informationalQnt;


// Substitui os placeholders pelo conteúdo do JSON
doc.setData(data);

try {
    // Renderiza o documento com os dados
    doc.render()
} catch (error) {
    // Captura e loga erros de renderização
    const e = {
        message: error.message,
        name: error.name,
        stack: error.stack,
        properties: error.properties,
    };
    console.log(JSON.stringify({error: e}));
    throw error;
}

const buf = doc.getZip()
             .generate({type: 'nodebuffer'});

// Salva o novo documento
fs.writeFileSync('outputs/result.docx', buf);

console.log('Report generated successfully!');
